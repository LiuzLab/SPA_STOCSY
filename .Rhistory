knitr::opts_chunk$set(echo = TRUE)
library(ggplot2)
library(baseline)
library(msProcess)
library(splus2R)
##specify paths to load the source codes, input data and save the output files
code_dir <- "~/Desktop/SPA-STOCSY/submit_github/source_codes/"
data_dir <- "~/Desktop/SPA-STOCSY/submit_github/input_data/"
output_dir <- "~/Desktop/SPA-STOCSY/submit_github/output/"
setwd(code_dir)
{source("Gen.spa.group_113011.R")
source("pred.strength.r")
source("Ints_avg_mod.r")
source("Select.gam.r")
source("Cor.stat.r")
source("Cor_landscape.r")
source("Landscape_cut.r")
source("Clust.member.r")
source("Gen_co_member.r")
source("Gen.ct.r")
source("peaks.correct.r")
source("norm_kern.r")
source("tri_cube_kern.r")
source("Epane_kern.r")
source("plot.land.r")
source("plot_pred.streth.r")
source("PQ_norm_113011_signal_v1.r")
source("Noise.estimate_113011.r")
source("baseline_removal_113011.r")
source("align.r")
source("ms_peak_123011.r")
source("peak_detection_cwt_v2.r")
source("Peak_simple_112111.r")
source("myImagePlot2.r")
source("gen.J.couple.r")
source("clus.r")
source("clus_region.r")
source("combine_cluster_peak.r")
source("gen_summary_profile.r")
source("gen_SPA_peaks.r")
source("gen_stocsy_corr_clusters.r")
source("Build_new.r")
source("PkinReg.r")
source("Auto_dect_one.r")
source("ftn.r")
source("FindMeta.r")
}
setwd(data_dir)
filename = "htt_c12.csv"
htt.dat <- read.csv(filename, header = T)
ppm0 <- htt.dat[,1]
dat0 <- t(htt.dat[, -1])
avg <- apply(dat0, 2, mean)
n.tr <- dim(dat0)[1]/2
n.cv <- 10
region = c(-.05, .05)
ppm = ppm0
##find alignment marker
ali.mark =  ppm[which.min(abs(ppm))]
dat = dat0
dim(dat)
region = c(-.05, .05)
ppm = ppm0
##find alignment marker
ali.mark =  ppm[which.min(abs(ppm))]
dat = dat0
##use Align function
ares <- Align(region, dat, ppm, ali.mark)
ahtt <- ares$tdat
appm <- ares$appm
avg.c <- apply(ahtt, 1, mean)
# set new standard:
ppm0 = appm
dat0 = ahtt
print("Alignment results:")
region=which((appm>(-0.1))&(appm<0.05))
{plot(appm[region],ahtt[region,10],type="l",
ylab="Intensity (a.u.)",xlab="Chemical shift (ppm)")
lines(appm[region],ahtt[region,2],col="red")
lines(appm[region],ahtt[region,3],col="green")
lines(appm[region],ahtt[region,4],col="blue")
lines(appm[region],ahtt[region,5],col="purple")
lines(appm[region],ahtt[region,6],col="orange")
lines(appm[region],ahtt[region,7],col="pink")
lines(appm[region],ahtt[region,8],col="yellow")
lines(appm[region],ahtt[region,9],col="skyblue")
lines(appm[region],ahtt[region,1],col="dark green")
}
?baseline
?getCorrected
dat.bl.rm <- baseline_removal(dat)
dat <- t(dat0)
ppm <- ppm0
dat.bl.rm <- baseline_removal(dat)
dat.bl <- dat.bl.rm$dat.bl
avg.bl <- apply(dat.bl, 2, mean)
print("Baseline corretion results:")
{plot(ppm,avg.c,type="l",xlab="Chemical shift (ppm)",ylab="Intensity (a.u.)",col="black")
lines(ppm,avg.bl,col="red")
legend(2.8,0.0043,legend=c("Original","Base_corrected"),
col=c("black","red"),lty=1,cex=0.8)}
dat.bl1 <- dat.bl
dat.bl1 <- dat.bl1[, which(ppm < 4 & ppm >0.5)]
ppm1 <- ppm[which(ppm < 4 & ppm >0.5)]
dim(dat.bl1)
length(ppm1)
nos.est <- Noise.est(dat.bl, pos.standar = c(0.08, 0.58), ppm)
nos <- nos.est * 5
nos
qplot(ppm[which(ppm>0.5)], avg.bl[which(ppm>0.5)], geom = "line") +
geom_hline(yintercept = nos,col="red")+
xlab("Chemical shift (ppm)")+
ylab("Intensity (a.u.)")+
scale_x_reverse()
dim(t(dat.bl))
qut_dat.bl1 <- PQ_norm_signal(t(dat.bl), method = "median", ppm, c(0.08, 0.58))
qut_dat.bl1
PQ_norm_signal(t(dat.bl), method = "median", ppm, c(0.08, 0.58))
qut_dat.bl1 <- PQ_norm_signal(t(dat.bl), method = "median", ppm, c(0.08, 0.58))
quot.bl1 <- qut_dat.bl1$quot
quot.final.bl1 <- qut_dat.bl1$quot.final
quot.final.bl1
dat_pqnorm.bl1 <- matrix(NA, dim(dat.bl1)[1], dim(dat.bl1)[2])
for(i in 1 : length(quot.final.bl1)){
dat_pqnorm.bl1[i, ] <- dat.bl1[i, ] / quot.final.bl1[i]
}
# set noise to 0
dat_pqnorm.bl2 <- dat_pqnorm.bl1
dat_pqnorm.bl2[which(dat_pqnorm.bl2 < nos)] <- 0
dat_pqnorm.bl1 <- matrix(NA, dim(dat.bl1)[1], dim(dat.bl1)[2])
for(i in 1 : length(quot.final.bl1)){
dat_pqnorm.bl1[i, ] <- dat.bl1[i, ] / quot.final.bl1[i]
}
# set noise to 0
dat_pqnorm.bl2 <- dat_pqnorm.bl1
dat_pqnorm.bl2[which(dat_pqnorm.bl2 < nos)] <- 0
dat = dat_pqnorm.bl1
ppm = ppm1
avg.d1 <- apply(dat_pqnorm.bl1, 2, mean)
pacf(avg.d1)
?pacf
span = 3
a1 = 0.8
a2 = 0.999
n.gam = 50
b2 = 0.99
kern.type = "tri_cube"
k = 7
n.tr <- dim(dat)[1]/2
n.cv <- 10
##set up a path to save output from SPA function
path=output_dir
dim(dat)
grp.res=readRDS(paste(output_dir,"SPA_rds.rds",sep=""))
#cluster member assigned to every ppm point
clus.mem <- grp.res$clus.mem
#separation of ppm points into clusters and background
land.cut <- grp.res$land.cut
##boundary label for every cluster
bond <- grp.res$bond
##average hump intensities in every cluster
ints <- grp.res$ints
##chosen optimal threshold for the correlation
gam <- grp.res$gam
max(clus.mem)
dat.spa <- ints  # intensities are calcualted by averaging the hump intensities with in that cluster.
cor.dat.spa <- cor(ints)
dim(ints)
dim(cor.dat.spa)
range(cor.dat.spa)
myImagePlot2(cor.dat.spa)
heat.colors
?heat.colors
